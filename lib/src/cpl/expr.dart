// Copyright (c) 2019, Herman Bergwerf. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.

part of smt.cpl;

enum ExprType { variable, and, or, not, imply, iff }

/// Expression node of [type]. A variable may be identified using either a
/// [label] or an [index] (this is useful for internal variables generated by a
/// Tseytin transformation).
class Expr {
  final ExprType type;
  final String label;
  final int index;
  final List<Expr> arguments;

  Expr(this.type, [this.arguments = const [], this.label = '', this.index = -1])
      : assert((type == ExprType.variable) == (label.isNotEmpty || index >= 0)),
        assert(type == ExprType.variable ? arguments.isEmpty : true),
        assert(type == ExprType.not ? arguments.length == 1 : true),
        assert(type == ExprType.imply ? arguments.length == 2 : true),
        assert(type == ExprType.iff ? arguments.length >= 2 : true);

  bool get isVariable => type == ExprType.variable;
  bool get isAnd => type == ExprType.and;
  bool get isOr => type == ExprType.or;
  bool get isNot => type == ExprType.not;
  bool get isImply => type == ExprType.imply;
  bool get isIff => type == ExprType.iff;

  @override
  String toString() {
    switch (type) {
      case ExprType.variable:
        return label.isEmpty ? '#$index' : label;
      case ExprType.and:
        return '(${arguments.join(" /\\ ")})';
      case ExprType.or:
        return '(${arguments.join(" \\/ ")})';
      case ExprType.not:
        return '(~ ${arguments[0]})';
      case ExprType.imply:
        return '(${arguments.join(" -> ")})';
      case ExprType.iff:
        return '(${arguments.join(" <-> ")})';
    }
    return '';
  }
}

/// Convert [term] to expression given it contains only tuples of the form:
/// + `(and .*)` or `(/\ .*)`
/// + `(or .*)` or `(\/ .*)`
/// + `(not .)` or `(~ .)`
/// + `(imply . .)` or `(-> . .)`
/// + `(iff .*)` or `(<-> .*)`
/// + `(_ .*)`
/// + `(? .)`
Expr convertCplTermToExpr(CplTerm term, Map<String, bool> assignment) {
  switch (term.type) {
    case CplTermType.name:
      // Check for macro references.
      if (term.name.startsWith('#')) {
        throw CplException('unknown macro reference ${term.name}');
      }
      return Expr(ExprType.variable, [], term.name);

    case CplTermType.number:
      // Convert number to string (some variables are composed of numbers, for
      // example `(_ a 1)` is converted to `a_1`).
      return Expr(ExprType.variable, [], '${term.number}');

    case CplTermType.tuple:
      // Generate all sub-terms.
      final subTerms = term.terms
          .sublist(1)
          .map((t) => convertCplTermToExpr(t, assignment))
          .toList();

      switch (extractName(term.terms[0])) {
        case 'and':
        case '/\\':
          return Expr(ExprType.and, subTerms);

        case 'or':
        case '\\/':
          return Expr(ExprType.or, subTerms);

        case 'not':
        case '~':
          cplAssert(() => subTerms.length == 1);
          return Expr(ExprType.not, subTerms);

        case 'imply':
        case '->':
          cplAssert(() => subTerms.length == 2);
          return Expr(ExprType.imply, subTerms);

        case 'iff':
        case '<->':
          cplAssert(() => subTerms.length >= 2);
          return Expr(ExprType.iff, subTerms);

        case '_':
          cplAssert(() => subTerms.isNotEmpty);
          cplAssert(() => subTerms.every((t) => t.isVariable));
          final label = subTerms.map((t) => t.label).join('_');
          return Expr(ExprType.variable, [], label);

        case '?':
          cplAssert(() => subTerms.length == 1);
          cplAssert(() => subTerms[0].isVariable);
          if (assignment != null && assignment.containsKey(subTerms[0].label)) {
            final isTrue = assignment[subTerms[0].label];
            return isTrue ? subTerms[0] : Expr(ExprType.not, subTerms);
          } else {
            throw CplException('no assignment for ${subTerms[0].label}');
          }
      }
      throw const CplException('unknown format');

    default: // null
      throw const CplException('null term');
  }
}

/// Negate [expr].
Expr negateExpr(Expr expr) => Expr(ExprType.not, [expr]);

/// Convert nested expressions of [type] to a flat list of arguments.
List<Expr> flattenExpr(ExprType type, Expr expr) => expr.type == type
    ? expr.arguments.expand((a) => flattenExpr(type, a)).toList()
    : [expr];

/// Convert bi-implication to two implications.
Expr unfoldIff(Expr left, Expr right) => Expr(ExprType.and, [
      Expr(ExprType.imply, [left, right]),
      Expr(ExprType.imply, [right, left])
    ]);
