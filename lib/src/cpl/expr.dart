// Copyright (c) 2019, Herman Bergwerf. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.

part of smt.cpl;

enum ExprType { variable, not, and, or, imply, iff }

/// Expression node of [type]. A variable may be identified using either a
/// [label] or an [index] (this is useful for internal variables generated by a
/// Tseytin transformation).
class Expr {
  final ExprType type;
  final String label;
  final int index;
  final List<Expr> arguments;

  Expr(this.type, [this.arguments = const [], this.label = '', this.index = -1])
      : assert((type == ExprType.variable) == (label.isNotEmpty || index >= 0)),
        assert(type == ExprType.variable ? arguments.isEmpty : true),
        assert(type == ExprType.not ? arguments.length == 1 : true),
        assert(type == ExprType.imply ? arguments.length == 2 : true),
        assert(type == ExprType.iff ? arguments.length >= 2 : true);

  factory Expr.variable(String label) => Expr(ExprType.variable, [], label);
  factory Expr.indexVar(int index) => Expr(ExprType.variable, [], '', index);
  factory Expr.not(Expr p) => Expr(ExprType.not, [p]);
  factory Expr.and(List<Expr> a) => Expr(ExprType.and, a);
  factory Expr.or(List<Expr> a) => Expr(ExprType.or, a);
  factory Expr.imply(Expr p, Expr q) => Expr(ExprType.imply, [p, q]);
  factory Expr.iff(List<Expr> a) => Expr(ExprType.iff, a);

  bool get isVariable => type == ExprType.variable;
  bool get isNot => type == ExprType.not;
  bool get isAnd => type == ExprType.and;
  bool get isOr => type == ExprType.or;
  bool get isImply => type == ExprType.imply;
  bool get isIff => type == ExprType.iff;

  @override
  String toString() {
    switch (type) {
      case ExprType.variable:
        return label.isEmpty ? '#$index' : label;
      case ExprType.not:
        return '(~ ${arguments[0]})';
      case ExprType.and:
        return '(${arguments.join(" /\\ ")})';
      case ExprType.or:
        return '(${arguments.join(" \\/ ")})';
      case ExprType.imply:
        return '(${arguments.join(" -> ")})';
      case ExprType.iff:
        return '(${arguments.join(" <-> ")})';
    }
    return '';
  }
}

/// Convert [term] to expression given it contains only tuples of the form:
/// + `(empty)`
/// + `(and .*)` or `(/\ .*)`
/// + `(or .*)` or `(\/ .*)`
/// + `(not .)` or `(~ .)`
/// + `(imply . .)` or `(implies . .)` or `(-> . .)`
/// + `(iff .*)` or `(<-> .*)`
/// + `(_ .*)`
/// + `(? .)`
Expr convertCplTermToExpr(CplTerm term, Map<String, bool> assignment) {
  switch (term.type) {
    case CplTermType.name:
      // Check for macro references.
      if (term.name.startsWith('#')) {
        throw CplException('unknown macro reference ${term.name}');
      }
      return Expr.variable(term.name);

    case CplTermType.number:
      // Convert number to string (some variables are composed of numbers, for
      // example `(_ a 1)` is converted to `a_1`).
      return Expr.variable('${term.number}');

    case CplTermType.tuple:
      // Generate all sub-terms.
      final subTerms = term.terms
          .sublist(1)
          .map((t) => convertCplTermToExpr(t, assignment))
          .where((t) => t != null)
          .toList();

      switch (extractName(term.terms[0])) {
        case 'empty':
          cplAssert(() => subTerms.isEmpty);
          return null;

        case 'not':
        case '~':
          cplAssert(() => subTerms.length == 1);
          return Expr.not(subTerms[0]);

        case 'and':
        case '/\\':
          return Expr.and(subTerms);

        case 'or':
        case '\\/':
          return Expr.or(subTerms);

        case 'imply':
        case 'implies':
        case '->':
          cplAssert(() => subTerms.length == 2);
          return Expr.imply(subTerms[0], subTerms[1]);

        case 'iff':
        case '<->':
          cplAssert(() => subTerms.length >= 2);
          return Expr.iff(subTerms);

        case '_':
          cplAssert(() => subTerms.isNotEmpty);
          cplAssert(() => subTerms.every((t) => t.isVariable));
          return Expr.variable(subTerms.map((t) => t.label).join('_'));

        case '?':
          cplAssert(() => subTerms.length == 1);
          cplAssert(() => subTerms[0].isVariable);
          if (assignment != null && assignment.containsKey(subTerms[0].label)) {
            final isTrue = assignment[subTerms[0].label];
            return isTrue ? subTerms[0] : Expr.not(subTerms[0]);
          } else {
            throw CplException('no assignment for ${subTerms[0].label}');
          }
      }
      throw const CplException('unknown format');

    default: // null
      throw const CplException('null term');
  }
}

/// Check if [x] is a literal (a variable or the negation of a variable).
bool isLiteral(Expr x) => x.isVariable || x.isNot && x.arguments[0].isVariable;

/// Convert bi-implication to two implications.
Expr unfoldIff(Expr left, Expr right) =>
    Expr.and([Expr.imply(left, right), Expr.imply(right, left)]);

/// Convert nested expressions of [type] to a flat list of arguments.
List<Expr> flattenExpr(ExprType type, Expr expr) => expr.type == type
    ? expr.arguments.expand((a) => flattenExpr(type, a)).toList()
    : [expr];

/// Eliminate double negations in [x].
Expr removeDoubleNegations(Expr x) {
  if (x.isNot && x.arguments[0].isNot) {
    return removeDoubleNegations(x.arguments[0].arguments[0]);
  } else {
    final arguments = x.arguments.map(removeDoubleNegations).toList();
    return Expr(x.type, arguments, x.label, x.index);
  }
}
